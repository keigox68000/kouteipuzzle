<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-TF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>中学校技術科 学習用パズルゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .drag-over {
            border: 2px dashed #3b82f6; /* blue-500 */
            background-color: #eff6ff; /* blue-50 */
        }
        .dragging {
            opacity: 0.5;
            background-color: #dbeafe; /* blue-100 */
        }
        .tool-tag {
            display: inline-block;
            background-color: #e0e7ff; /* indigo-100 */
            color: #3730a3; /* indigo-800 */
            padding: 2px 8px;
            border-radius: 9999px; /* rounded-full */
            margin: 2px;
            font-size: 0.875rem; /* text-sm */
            cursor: pointer;
        }
        .tool-tag:hover {
            background-color: #c7d2fe; /* indigo-200 */
        }
        /* For better visual feedback on draggable rows */
        .draggable-row:hover {
            background-color: #f3f4f6; /* gray-100 */
            cursor: grab;
        }
        .draggable-row.dragging {
            background-color: #e5e7eb; /* gray-200 */
        }
        .tool-item {
            cursor: grab;
            transition: transform 0.1s ease-in-out;
        }
        .tool-item:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        .placeholder-text-sm { /* Custom class for smaller placeholder text */
            font-size: 0.6rem !important;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">
    <div class="container mx-auto p-4 min-h-screen flex flex-col">
        <header class="mb-6 text-center">
            <h1 class="text-3xl font-bold text-sky-700">製作工程表パズル</h1>
            <p class="text-lg text-slate-600">「文庫本立てA」の製作工程を並び替え、使用する工具を配置しましょう。</p>
        </header>

        <div class="flex flex-col lg:flex-row gap-6 flex-grow">
            <div class="lg:w-3/4 bg-white p-6 rounded-xl shadow-lg">
                <div class="flex justify-between items-center mb-4">
                    <div>
                        <label for="studentName" class="text-sm font-medium text-slate-700">氏名:</label>
                        <input type="text" id="studentName" class="ml-2 p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                    </div>
                    <button id="resetButton" class="px-6 py-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-400 focus:ring-opacity-75 transition duration-150">
                        リセット
                    </button>
                </div>

                <div class="overflow-x-auto">
                    <table class="w-full border-collapse border border-slate-300 shadow-sm rounded-lg">
                        <thead class="bg-sky-100 text-sky-700">
                            <tr>
                                <th class="border border-slate-300 p-3 text-left text-sm font-semibold w-1/12">No.</th>
                                <th class="border border-slate-300 p-3 text-left text-sm font-semibold w-3/12">工程</th>
                                <th class="border border-slate-300 p-3 text-left text-sm font-semibold w-5/12">主な作業</th>
                                <th class="border border-slate-300 p-3 text-left text-sm font-semibold w-3/12">使用する工具</th>
                            </tr>
                        </thead>
                        <tbody id="puzzleTableBody">
                            </tbody>
                    </table>
                </div>
            </div>

            <div class="lg:w-1/4 bg-slate-100 p-6 rounded-xl shadow-lg">
                <h2 class="text-xl font-semibold mb-4 text-center text-sky-700">工具エリア</h2>
                <div id="toolbox" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-2 gap-4">
                    </div>
            </div>
        </div>
    </div>

    <script>
        // --- Game Data ---
        const initialGameData = {
            processes: [
                { id: 'proc_kegaki', processName: 'けがき', tasks: ['① けがき の 基準 面 を 決める', '② 基準 面 を 基準 に し て 、 材料 に 切断 線 や 仕上がり 寸法 線 を 書く', '③ 寸法 どおり に けが か れ て いる か 検査 する'], tools: [], correctOrder: 0 },
                { id: 'proc_setsudan', processName: '切断', tasks: ['① 切断 線 や 仕上がり 寸法 線 に 従っ て 切断 する', '② 材料 が 正しく 取れ た か 検査 する'], tools: [], correctOrder: 1 },
                { id: 'proc_buhinkako', processName: '部品加工', tasks: ['① 切断 し た 部品 の 仕上がり 寸法 を 確認 する', '② 部品 を 削っ て 仕上がり 寸法 に 加工 する', '③ 部品 加工 の 検査 を する'], tools: [], correctOrder: 2 },
                { id: 'proc_kumitate', processName: '組み立て', tasks: ['① 仮組 を し て 仕上がり を 確認 する', '② 接合 部 の けがき を する', '③ くぎ の 下穴 の 場所 に 印 を つける', '④ 下穴 を 開ける', '⑤ くぎ を 使っ て 接合 する'], tools: [], correctOrder: 3 },
                { id: 'proc_shiage', processName: '仕上げ', tasks: ['① 全体 の 仕上がり を 検査 する (直角 、 長 さ)', '② 必要 に 応じ て やすり で 削る', '③ 全体 を 紙 やすり で みがく'], tools: [], correctOrder: 4 }
            ],
            availableTools: [
                { id: 'tool_sashigane', name: 'さしがね', imageUrl: 'https://placehold.co/100x80/EFF6FF/1E40AF?text=さしがね&font=arial&font-size=14' },
                { id: 'tool_enpitsu', name: '鉛筆', imageUrl: 'https://placehold.co/100x80/EFF6FF/1E40AF?text=鉛筆&font=arial&font-size=14' },
                { id: 'tool_nokogiri', name: 'のこぎり', imageUrl: 'https://placehold.co/100x80/EFF6FF/1E40AF?text=のこぎり&font=arial&font-size=14' },
                { id: 'tool_kurampu', name: 'クランプ', imageUrl: 'https://placehold.co/100x80/EFF6FF/1E40AF?text=クランプ&font=arial&font-size=14' },
                { id: 'tool_yasuri', name: '木工やすり', imageUrl: 'https://placehold.co/100x80/EFF6FF/1E40AF?text=木工やすり&font=arial&font-size=12' },
                { id: 'tool_doriru', name: 'ドリル', imageUrl: 'https://placehold.co/100x80/EFF6FF/1E40AF?text=ドリル&font=arial&font-size=14' },
                { id: 'tool_gennou', name: 'げんのう', imageUrl: 'https://placehold.co/100x80/EFF6FF/1E40AF?text=げんのう&font=arial&font-size=14' },
                { id: 'tool_kamiyasuri', name: '紙やすり', imageUrl: 'https://placehold.co/100x80/EFF6FF/1E40AF?text=紙やすり&font=arial&font-size=14' },
                { id: 'tool_kugi', name: 'くぎ', imageUrl: 'https://placehold.co/100x80/EFF6FF/1E40AF?text=くぎ&font=arial&font-size=14' },
                { id: 'tool_nokogiri_guide', name: 'のこガイド', imageUrl: 'https://placehold.co/100x80/EFF6FF/1E40AF?text=のこガイド&font=arial&font-size=12' },
            ]
        };

        let currentProcesses = [];
        let draggedProcessId = null;
        const localStorageKey = 'gijutsuPuzzleGameState_v1';
        const studentNameKey = 'gijutsuPuzzleStudentName_v1';

        // --- Utility Functions ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- Rendering Functions ---
        function renderTable() {
            const tableBody = document.getElementById('puzzleTableBody');
            tableBody.innerHTML = ''; // Clear existing rows

            currentProcesses.forEach((process, index) => {
                const row = tableBody.insertRow();
                row.id = process.id;
                row.draggable = true;
                row.classList.add('draggable-row', 'border-b', 'border-slate-200', 'hover:bg-slate-50', 'transition-colors', 'duration-150');

                // Drag and drop event listeners for rows
                row.addEventListener('dragstart', (e) => handleProcessDragStart(e, process.id));
                row.addEventListener('dragover', handleProcessDragOver);
                row.addEventListener('drop', (e) => handleProcessDrop(e, process.id));
                row.addEventListener('dragend', handleProcessDragEnd);
                
                // No. cell
                const noCell = row.insertCell();
                noCell.textContent = index + 1;
                noCell.classList.add('p-3', 'text-sm', 'text-slate-600', 'text-center', 'align-top');

                // Process Name cell
                const processCell = row.insertCell();
                processCell.textContent = process.processName;
                processCell.classList.add('p-3', 'text-sm', 'font-medium', 'text-slate-700', 'align-top');

                // Tasks cell
                const tasksCell = row.insertCell();
                tasksCell.innerHTML = process.tasks.join('<br>');
                tasksCell.classList.add('p-3', 'text-sm', 'text-slate-600', 'align-top', 'leading-relaxed');

                // Tools cell (droppable area)
                const toolsCell = row.insertCell();
                toolsCell.id = `tools-${process.id}`;
                toolsCell.classList.add('p-3', 'text-sm', 'text-slate-600', 'align-top', 'min-h-[50px]'); // min-h for better drop target
                toolsCell.addEventListener('dragover', handleToolDragOver);
                toolsCell.addEventListener('drop', (e) => handleToolDrop(e, process.id));
                renderToolsInCell(process.id, process.tools);
            });
        }

        function renderToolsInCell(processId, tools) {
            const toolsCell = document.getElementById(`tools-${processId}`);
            if (!toolsCell) return;
            toolsCell.innerHTML = ''; // Clear existing tools
            if (tools && tools.length > 0) {
                tools.forEach(toolName => {
                    const toolTag = document.createElement('span');
                    toolTag.textContent = toolName;
                    toolTag.classList.add('tool-tag');
                    toolTag.title = 'クリックして削除'; // Click to remove
                    toolTag.onclick = () => removeToolFromProcess(toolName, processId);
                    toolsCell.appendChild(toolTag);
                });
            } else {
                toolsCell.innerHTML = '<span class="text-slate-400 text-xs">ここに工具をドラッグ</span>';
            }
        }
        
        function removeToolFromProcess(toolNameToRemove, processId) {
            const process = currentProcesses.find(p => p.id === processId);
            if (process) {
                process.tools = process.tools.filter(t => t !== toolNameToRemove);
                renderToolsInCell(processId, process.tools);
                saveState();
            }
        }


        function renderToolbox() {
            const toolbox = document.getElementById('toolbox');
            toolbox.innerHTML = ''; // Clear existing tools

            initialGameData.availableTools.forEach(tool => {
                const toolDiv = document.createElement('div');
                toolDiv.classList.add('tool-item', 'p-2', 'border', 'border-slate-300', 'rounded-lg', 'shadow-sm', 'bg-white', 'flex', 'flex-col', 'items-center', 'text-center', 'hover:shadow-md', 'transition-shadow');
                toolDiv.draggable = true;
                toolDiv.id = tool.id;

                const img = document.createElement('img');
                img.src = tool.imageUrl;
                img.alt = tool.name;
                img.classList.add('w-full', 'h-auto', 'object-contain', 'mb-1', 'rounded');
                img.ondragstart = (e) => e.preventDefault(); // Prevent native image drag ghost

                const name = document.createElement('span');
                name.textContent = tool.name;
                name.classList.add('text-xs', 'font-medium', 'text-slate-700');
                
                toolDiv.appendChild(img);
                toolDiv.appendChild(name);

                toolDiv.addEventListener('dragstart', (e) => handleToolDragStart(e, tool));
                toolbox.appendChild(toolDiv);
            });
        }

        // --- Drag and Drop Handlers for Processes ---
        function handleProcessDragStart(event, processId) {
            draggedProcessId = processId;
            event.dataTransfer.setData('text/plain', processId);
            event.dataTransfer.effectAllowed = 'move';
            event.currentTarget.classList.add('dragging');
        }

        function handleProcessDragOver(event) {
            event.preventDefault(); // Necessary to allow dropping
            event.dataTransfer.dropEffect = 'move';
            const targetRow = event.currentTarget;
            if (targetRow.id !== draggedProcessId) {
                 targetRow.classList.add('drag-over');
            }
        }
        
        document.getElementById('puzzleTableBody').addEventListener('dragleave', (event) => {
            if (event.target.tagName === 'TR' && event.target.classList.contains('draggable-row')) {
                event.target.classList.remove('drag-over');
            }
        });


        function handleProcessDrop(event, targetProcessId) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            if (draggedProcessId === targetProcessId) return;

            const draggedIndex = currentProcesses.findIndex(p => p.id === draggedProcessId);
            const targetIndex = currentProcesses.findIndex(p => p.id === targetProcessId);

            if (draggedIndex !== -1 && targetIndex !== -1) {
                const [draggedItem] = currentProcesses.splice(draggedIndex, 1);
                currentProcesses.splice(targetIndex, 0, draggedItem);
                renderTable();
                saveState();
            }
        }

        function handleProcessDragEnd(event) {
            event.currentTarget.classList.remove('dragging');
            // Clear any remaining drag-over styles from all rows
            document.querySelectorAll('#puzzleTableBody tr').forEach(row => {
                row.classList.remove('drag-over');
            });
            draggedProcessId = null;
        }

        // --- Drag and Drop Handlers for Tools ---
        function handleToolDragStart(event, tool) {
            event.dataTransfer.setData('application/json', JSON.stringify(tool));
            event.dataTransfer.effectAllowed = 'copy';
            // Optional: visual feedback for dragging tool
             event.currentTarget.classList.add('opacity-50');
        }
        
        document.getElementById('toolbox').addEventListener('dragend', (event) => {
            if (event.target.classList.contains('tool-item')) {
                 event.target.classList.remove('opacity-50');
            }
        });

        function handleToolDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
            event.currentTarget.classList.add('drag-over'); // Highlight drop target cell
        }
        
        // Add dragleave to tool drop cells
        document.getElementById('puzzleTableBody').addEventListener('dragleave', (event) => {
            // Check if the event target is a TD cell for tools
            if (event.target.tagName === 'TD' && event.target.id.startsWith('tools-')) {
                event.target.classList.remove('drag-over');
            }
        });


        function handleToolDrop(event, targetProcessId) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            const toolDataString = event.dataTransfer.getData('application/json');
            if (!toolDataString) return;

            const tool = JSON.parse(toolDataString);
            const process = currentProcesses.find(p => p.id === targetProcessId);

            if (process) {
                if (!process.tools.includes(tool.name)) { // Avoid duplicate tools in the same cell
                    process.tools.push(tool.name);
                }
                renderToolsInCell(targetProcessId, process.tools);
                saveState();
            }
        }

        // --- State Management (localStorage) ---
        function saveState() {
            const state = {
                processes: currentProcesses,
            };
            localStorage.setItem(localStorageKey, JSON.stringify(state));
        }

        function loadState() {
            const savedState = localStorage.getItem(localStorageKey);
            if (savedState) {
                const state = JSON.parse(savedState);
                // Ensure loaded data structure is valid and has all expected fields
                currentProcesses = state.processes.map(savedProc => {
                    const initialProc = initialGameData.processes.find(ip => ip.id === savedProc.id);
                    return {
                        ...initialProc, // get tasks, correctOrder from initial data
                        ...savedProc // override with saved processName (if changed), and tools
                    };
                });
                // Verify all initial processes are present, add if missing (e.g., after an update to initialGameData)
                initialGameData.processes.forEach(initialProc => {
                    if (!currentProcesses.find(cp => cp.id === initialProc.id)) {
                        currentProcesses.push(JSON.parse(JSON.stringify(initialProc))); // Add missing, deep copy
                    }
                });
                // Remove processes from currentProcesses if they no longer exist in initialGameData
                currentProcesses = currentProcesses.filter(cp => initialGameData.processes.some(ip => ip.id === cp.id));

            } else {
                // Initialize with a shuffled order
                currentProcesses = JSON.parse(JSON.stringify(initialGameData.processes)); // Deep copy
                shuffleArray(currentProcesses);
            }
        }

        // --- Initialization and Reset ---
        function initializeGame() {
            loadState(); // Load saved state or initialize
            renderTable();
            renderToolbox();

            // Load and set student name
            const studentNameInput = document.getElementById('studentName');
            const savedName = localStorage.getItem(studentNameKey);
            if (savedName) {
                studentNameInput.value = savedName;
            }
            studentNameInput.addEventListener('input', (e) => {
                localStorage.setItem(studentNameKey, e.target.value);
            });

            // Reset button
            document.getElementById('resetButton').addEventListener('click', resetGame);
        }

        function resetGame() {
            if (confirm('本当にリセットしますか？現在の進捗は失われます。')) {
                localStorage.removeItem(localStorageKey);
                currentProcesses = JSON.parse(JSON.stringify(initialGameData.processes)); // Deep copy
                shuffleArray(currentProcesses);
                // Clear tools from all processes in the newly shuffled array
                currentProcesses.forEach(proc => proc.tools = []);
                renderTable();
                saveState(); // Save the fresh, shuffled, tool-empty state
                 // Optionally clear student name:
                // document.getElementById('studentName').value = '';
                // localStorage.removeItem(studentNameKey);
            }
        }

        // --- Start the game ---
        document.addEventListener('DOMContentLoaded', initializeGame);

    </script>
</body>
</html>
